# Table of Contents
1. [Overview](#overview)
2. [Performance](#performance)
3. [How](#how)
4. [Usage](#usage)
5. [Caveats](#caveats)

# Overview

This repository provides users the ability to use spirv-cross and glslang without having
to include a dependency which bundles native libraries for each platform. That is to say
the full original functionality of these libraries are provided solely by JVM native
dependencies.

# Performance
The code generated via the codegen module is about 2.5x faster than just using chicory itself.
When chicory generates JVM bytecode every method has to chaperone around a Memory and Instance
parameter which is not the best for performance as each memory lookup will be virtualized, and
overhead will be associated with each method call. This is overcome by making the memory static
and having the initial memory be loaded, in the static initializer. The table which is used to 
perform indirect calls are also inlined into the generated bytecode. 

Furthermore many method calls are made to execute simple operations which is not too detrimental
to performance however it can add some overhead before the JIT has inlined the methods. 
Chicory also has some safety checks which are completely emitted such as checking for thread interruptions.
Unsafe is used to perform memory lookups which when JIT-ed should results in simple 
memory load / store instructions, however failures will likely result in a JVM crash.

In relation to native libraries it's much slower at about 20% the performance of native.

# How
First the native libraries are compiled to wasm modules using the emscripten toolchain. Then
the chicory library is used to parse the wasm module. The wasm instructions are then 
converted to java bytecode using the ASM library. The generated java bytecode is mixed with 
the CompiledModule class which provides memory load store operations. The imports of the module
are made into an interface, and the exports are provided by the respective library name followed
by interface. e.g. GlslangInterface and SpvcInterface. If you read the paragraph above you may
ask how its possible to have multi instances of the module since the memory is static, which is 
visible by looking at the CompiledModule class. This is achieved by creating the class multiple
times by using a throwaway classloader. These class instances are then accessed using method handles
from their respective library interfaces. InvokeExact is used which should eliminate any overhead
from boxing / unboxing parameters and return values.

# Usage
The usage of the libraries themselves are not documented in this project and one should refer
to the original repositories to view their C apis. 

Each library has a basic test which can get one setup fairly quickly. The GlslangTest shows
how to convert a GLSL shader to SPIR-V. The SpvcTest also shows the former and then how to convert the
generated SPIRV to a HLSL shader. 

Each module only has 16 MB of memory to use, therefore you should manage it's memory properly otherwise
you may get unexpected behaviour. Each module instanciation uses off heap memory, this off heap memory
is freed which you call heap_free, apart from this no further cleanup is needed apart from removing
references from your code so that the GC can cleanup the class instance. 

Before using any of the wasm functions you must call _initialize. The initialize execution times can be 
a bit slow and I'm not sure any following new instances will be any faster because each new instance
is a new class instance. But typically I saw around 5-10ms to convert a shader to spirv after the warm-up
phase, the first run may take 500+ ms therefore maybe it is worth passing garbage shaders at application
launch to get the instanced JIT-ed. 

# Caveats
The code generator in this project has only been made to handle the instructions used by the included
libraries and is not suitable for other wasm modules, that is not to say it won't work with other wasm
modules but it probably would need some work to get it functioning.

Another issue is user defined callback functions, which at the moment don't work and I believe isn't compatible
with normal wasm modules, although a hack could be made to get it to work. 



